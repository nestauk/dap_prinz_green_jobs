"""
Custom prodigy recipe to generate both NER start and end tokens of company description
    and the predicted SIC code using an LLM.
"""
import langchain
from langchain.llms import OpenAI
from langchain.output_parsers import StructuredOutputParser, ResponseSchema
from langchain.prompts import PromptTemplate
from pathlib import Path

from dotenv import load_dotenv
import copy
import os
import re
from typing import Dict, Iterator, List, Union

import prodigy
import spacy
from prodigy.components.loaders import JSONL
from prodigy.components.preprocess import add_tokens


load_dotenv()  # load the openAI key

if not os.getenv("OPENAI_API_KEY"):
    ValueError(
        "OPENAI_API_KEY not found in environment variables. Add key to .env file."
    )

model = OpenAI(temperature=0.0)

prodigy_schema = [
    ResponseSchema(
        name="sic_code",
        description="predicted SIC code for the input text. Must be a Standardised Industry Code.",
    ),
    ResponseSchema(
        name="sic_name",
        description="predicted SIC code name for the input text. Must be the description of the Standardised Industry Code.",
    ),
    ResponseSchema(
        name="sic_phrase",
        description="Phrase that was used to predict the SIC code from the job advert text. It must be a string.",
    ),
    ResponseSchema(
        name="token_start",
        description="Token start index of phrase used to predict the SIC code from the job advert text. Must be a integer.",
    ),
    ResponseSchema(
        name="token_end",
        description="Token end index of phrase used to predict the SIC code from the job advert text. Must be a integer.",
    ),
    ResponseSchema(
        name="start",
        description="Character start index of phrase used to predict the SIC code from the job advert text. Must be a integer.",
    ),
    ResponseSchema(
        name="end",
        description="Character end index of phrase used to predict the SIC code from the job advert text. Must be a integer.",
    ),
]


def _make_prompt(
    schema: List[ResponseSchema] = prodigy_schema,
) -> Union[PromptTemplate, StructuredOutputParser]:
    """Generate the prompt template and ouput parser for the recipe.

    Args:
        schema (List[ResponseSchema], optional): List of ResponseSchema objects. Defaults to prodigy_schema.

    Returns:
        Union[PromptTemplate, StructuredOutputParser]: PromptTemplate and StructuredOutputParser objects.
    """
    # parse the schema
    output_parser = StructuredOutputParser.from_response_schemas(schema)
    format_instructions = output_parser.get_format_instructions()

    # generate the prompt template
    prompt = PromptTemplate(
        template='Predict the SIC code and the phrase that generated the SIC code prediction in the job advert text.\n{format_instructions}\n The job advert text is in the triple quotes below: \n"""{job_advert}"""\n',
        input_variables=["job_advert"],
        partial_variables={"format_instructions": format_instructions},
    )

    return prompt, output_parser


def make_tasks(
    nlp: spacy.language.Language,
    stream: Iterator[dict],
    schema: List[ResponseSchema] = prodigy_schema,
    model: langchain.llms.OpenAI = model,
) -> Iterator[dict]:
    """Add predicted entities generated by OpenAI to the stream.

    Args:
        nlp (spacy.language.Language): spaCy language model
        schema (List[ResponseSchema]): List of ResponseSchema objects
        model (langchain.llms.OpenAI): OpenAI language model

    Yields:
        Iterator[dict]: Iterator of dictionaries with text and spans keys
    """
    prompt, output_parser = _make_prompt(schema)
    ner_keys = "start", "end", "token_start", "token_end", "label"
    texts = ((eg["text"], eg) for eg in stream)
    for doc, eg in nlp.pipe(texts, as_tuples=True):
        spans = []
        task = copy.deepcopy(eg)
        _input = prompt.format_prompt(job_advert=doc.text)
        output = model(_input.to_string())
        # light touch json cleaning if LLM returns a bad json
        if not output.endswith("```"):
            output = output[: output.rfind("\n")] + "```"
        try:
            output_parsed = output_parser.parse(output)
            output_parsed["label"] = "SIC_CODE"
        # deal with bad parsing and just let the labeller identify the SIC phrase and code
        except langchain.schema.OutputParserException:
            output_parsed = None
        print(output_parsed)
        if output_parsed:
            spans.append({k: v for k, v in output_parsed.items() if k in ner_keys})
        else:
            spans.append(
                {
                    "start": 0,
                    "end": 0,
                    "token_start": 0,
                    "token_end": 0,
                    "label": "SIC_CODE",
                }
            )

        task["spans"] = spans
        options = [
            {
                "id": 1,
                "text": f"{output_parsed['sic_code']} ({output_parsed['sic_name']})",
            },
            {"id": 2, "text": "wrong SIC code"},
        ]
        task["options"] = options

        yield task


@prodigy.recipe(
    "oa_ner_classification",
    dataset=("The dataset to use", "positional", None, str),
    source=("The source data as a .jsonl file", "positional", None, Path),
)
def custom_oa(dataset, source):
    # load blank spacy model
    nlp = spacy.blank("en")
    # add entity ruler pipe

    # Initialize the Prodigy stream
    stream = JSONL(source)

    # add tokens to the stream
    stream = add_tokens(nlp, stream)

    # add predicted entities and text to the stream
    stream = make_tasks(nlp, stream)

    return {
        "dataset": dataset,  # save annotations in this dataset
        "view_id": "blocks",  # use the blocks interface
        "stream": stream,
        "config": {
            "buttons": ["accept", "reject", "ignore"],
            "labels": ["SIC_CODE"],  # the label for the manual NER interface
            "blocks": [
                {"view_id": "ner_manual"},
                {"view_id": "choice", "text": None},
                {
                    "view_id": "text_input",
                    "field_rows": 1,
                    "field_label": "Correct SIC code, if needed:",
                },
            ],
            "custom_theme": {
                "labels": {"SIC_CODE": "#2592da"},
            },
        },
    }
